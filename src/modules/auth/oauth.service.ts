import jwt from 'jsonwebtoken';
import { config } from '../../config';
import { supabaseAdmin } from '../../config/supabase';
import { AppError } from '../../middleware/error.middleware';
import { CompanyService } from '../companies/companies.service';
import { UserRole } from '../../types/database.types';
import logger from '../../utils/logger';

export class OAuthService {
  /**
   * Get Supabase OAuth URL for a provider
   * This is used by the frontend to initiate OAuth flow with Supabase
   * 
   * @param provider - 'google' or 'github'
   * @param redirectTo - Frontend URL where Supabase will redirect after OAuth
   * @param options - Additional options (companyName, etc.)
   */
  static getSupabaseOAuthUrl(
    provider: 'google' | 'github',
    redirectTo: string,
    options?: { companyName?: string }
  ): string {
    // Supabase OAuth URLs are constructed by the frontend using signInWithOAuth()
    // This method returns the redirect URL that the frontend should use
    // The frontend will call: supabase.auth.signInWithOAuth({ provider, options: { redirectTo } })
    
    // For backend reference, we return the pattern
    // The actual URL is generated by Supabase client in the frontend
    const baseUrl = `${config.supabase.url}/auth/v1/authorize`;
    const params = new URLSearchParams({
      provider,
      redirect_to: redirectTo,
      ...(options?.companyName && { state: Buffer.from(options.companyName).toString('base64') }),
    });

    return `${baseUrl}?${params.toString()}`;
  }

  /**
   * Exchange Supabase session token for JWT token
   * Called by frontend after successful OAuth login via Supabase
   * 
   * @param supabaseAccessToken - The access token from Supabase session
   * @param companyName - Optional company name for new signups
   */
  static async exchangeSupabaseSession(
    supabaseAccessToken: string,
    companyName?: string
  ) {
    try {
      // Validate the Supabase session token
      const { data: authData, error: authError } = await supabaseAdmin.auth.getUser(supabaseAccessToken);

      if (authError || !authData.user) {
        logger.error('Invalid Supabase session token', { error: authError });
        throw new AppError('Invalid session token', 401);
      }

      const authUser = authData.user;
      const email = authUser.email;

      if (!email) {
        throw new AppError('User email not found', 400);
      }

      // Check if user profile exists in our database
      let { data: user } = await supabaseAdmin
        .from('users')
        .select('id, email, full_name, role, avatar_url, is_active, is_two_factor_enabled')
        .eq('id', authUser.id)
        .single() as any;

      const isNewUser = !user;

      // Sync user profile if new or update metadata
      if (isNewUser) {
        const metadata = authUser.user_metadata || {};
        const newUser = {
          id: authUser.id,
          email: email,
          full_name: metadata.full_name || metadata.name || email.split('@')[0],
          role: 'developer' as UserRole,
          avatar_url: metadata.avatar_url || metadata.picture || null,
        };

        const { data: createdUser, error: createError } = await (supabaseAdmin.from('users') as any)
          .insert(newUser)
          .select()
          .single();

        if (createError) {
          logger.error('Failed to create user profile', { error: createError });
          throw new AppError('Failed to sync user profile', 500);
        }

        user = createdUser;

        // Create default company for new users
        const defaultCompanyName = companyName || 
          `${metadata.full_name || metadata.name || email.split('@')[0]}'s Workspace`;
        
        await CompanyService.createCompany({
          name: defaultCompanyName,
          userId: user.id,
        });

        logger.info('New user created via OAuth', { userId: user.id, email, provider: authUser.app_metadata?.provider });
      } else {
        // Update user metadata if changed (avatar, name, etc.)
        const metadata = authUser.user_metadata || {};
        const updates: any = {};
        
        if (metadata.full_name && metadata.full_name !== user.full_name) {
          updates.full_name = metadata.full_name;
        }
        if (metadata.avatar_url && metadata.avatar_url !== user.avatar_url) {
          updates.avatar_url = metadata.avatar_url;
        }
        if (metadata.picture && metadata.picture !== user.avatar_url) {
          updates.avatar_url = metadata.picture;
        }

        if (Object.keys(updates).length > 0) {
          await (supabaseAdmin.from('users') as any)
            .update(updates)
            .eq('id', user.id);
          
          // Refresh user data
          const { data: updatedUser } = await supabaseAdmin
            .from('users')
            .select('id, email, full_name, role, avatar_url, is_active, is_two_factor_enabled')
            .eq('id', user.id)
            .single() as any;
          
          if (updatedUser) {
            user = updatedUser;
          }
        }
      }

      if (!user || !user.is_active) {
        throw new AppError('Account inactive or not found', 403);
      }

      // Get user's companies
      const companies = await CompanyService.getUserCompanies(user.id);
      const defaultCompany = companies.length > 0 ? companies[0] : null;

      // Generate JWT token
      const token = this.generateJWTToken(
        user.id,
        user.email,
        user.role,
        defaultCompany?.id
      );

      return {
        user: {
          id: user.id,
          email: user.email,
          fullName: user.full_name,
          role: user.role,
          avatarUrl: user.avatar_url,
        },
        token,
        companyId: defaultCompany?.id,
        companies: companies.map((c) => ({
          id: c.id,
          name: c.name,
          role: c.role,
        })),
        currentCompany: defaultCompany
          ? {
              id: defaultCompany.id,
              name: defaultCompany.name,
            }
          : undefined,
        require2fa: user.is_two_factor_enabled,
      };
    } catch (error) {
      if (error instanceof AppError) throw error;
      logger.error('Supabase session exchange error', { error });
      throw new AppError('Session exchange failed', 500);
    }
  }

  /**
   * Generate JWT token (same logic as AuthService)
   */
  private static generateJWTToken(userId: string, email: string, role: UserRole, companyId?: string): string {
    const payload: any = { sub: userId, email, role };
    if (companyId) {
      payload.companyId = companyId;
    }
    const secret = String(config.jwt.secret);
    return jwt.sign(payload, secret, { expiresIn: config.jwt.expiresIn as any });
  }
}

